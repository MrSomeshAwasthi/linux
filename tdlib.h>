select(2)                                           System Calls Manual                                           select(2)

NNAAMMEE
       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO, fd_set - synchronous I/O multiplexing

LLIIBBRRAARRYY
       Standard C library (_l_i_b_c, _-_l_c)

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssyyss//sseelleecctt..hh>>

       ttyyppeeddeeff /* ... */ ffdd__sseett;;

       iinntt sseelleecctt((iinntt _n_f_d_s,, ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _r_e_a_d_f_d_s,,
                  ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _w_r_i_t_e_f_d_s,,
                  ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _e_x_c_e_p_t_f_d_s,,
                  ssttrruucctt ttiimmeevvaall **__NNuullllaabbllee rreessttrriicctt _t_i_m_e_o_u_t));;

       vvooiidd FFDD__CCLLRR((iinntt _f_d,, ffdd__sseett **_s_e_t));;
       iinntt  FFDD__IISSSSEETT((iinntt _f_d,, ffdd__sseett **_s_e_t));;
       vvooiidd FFDD__SSEETT((iinntt _f_d,, ffdd__sseett **_s_e_t));;
       vvooiidd FFDD__ZZEERROO((ffdd__sseett **_s_e_t));;

       iinntt ppsseelleecctt((iinntt _n_f_d_s,, ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _r_e_a_d_f_d_s,,
                  ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _w_r_i_t_e_f_d_s,,
                  ffdd__sseett **__NNuullllaabbllee rreessttrriicctt _e_x_c_e_p_t_f_d_s,,
                  ccoonnsstt ssttrruucctt ttiimmeessppeecc **__NNuullllaabbllee rreessttrriicctt _t_i_m_e_o_u_t,,
                  ccoonnsstt ssiiggsseett__tt **__NNuullllaabbllee rreessttrriicctt _s_i_g_m_a_s_k));;

   Feature Test Macro Requirements for glibc (see ffeeaattuurree__tteesstt__mmaaccrrooss(7)):

       ppsseelleecctt():
           _POSIX_C_SOURCE >= 200112L

DDEESSCCRRIIPPTTIIOONN
       WWAARRNNIINNGG: sseelleecctt() can monitor only file descriptors numbers that are less than FFDD__SSEETTSSIIZZEE (1024)—an unreasonably low
       limit for many modern applications—and this limitation will not change.  All modern applications should instead  use
       ppoollll(2) or eeppoollll(7), which do not suffer this limitation.

       sseelleecctt()  allows  a  program to monitor multiple file descriptors, waiting until one or more of the file descriptors
       become "ready" for some class of I/O operation (e.g., input possible).  A file descriptor is considered ready if  it
       is  possible  to  perform  a  corresponding  I/O operation (e.g., rreeaadd(2), or a sufficiently small wwrriittee(2)) without
       blocking.

   ffdd__sseett
       A structure type that can represent a set of file descriptors.  According to POSIX, the maximum number of  file  de‐
       scriptors in an _f_d___s_e_t structure is the value of the macro FFDD__SSEETTSSIIZZEE.

   FFiillee ddeessccrriippttoorr sseettss
       The  principal arguments of sseelleecctt() are three "sets" of file descriptors (declared with the type _f_d___s_e_t), which al‐
       low the caller to wait for three classes of events on the specified set of file descriptors.  Each of the _f_d___s_e_t ar‐
       guments may be specified as NULL if no file descriptors are to be watched for the corresponding class of events.

       NNoottee wweellll: Upon return, each of the file descriptor sets is modified in place to indicate which file descriptors are
       currently "ready".  Thus, if using sseelleecctt() within a loop, the sets _m_u_s_t _b_e _r_e_i_n_i_t_i_a_l_i_z_e_d before each call.

       The contents of a file descriptor set can be manipulated using the following macros:

       FFDD__ZZEERROO()
              This macro clears (removes all file descriptors from) _s_e_t.  It should be employed as the first step  in  ini‐
              tializing a file descriptor set.

       FFDD__SSEETT()
              This  macro  adds the file descriptor _f_d to _s_e_t.  Adding a file descriptor that is already present in the set
              is a no-op, and does not produce an error.

       FFDD__CCLLRR()
              This macro removes the file descriptor _f_d from _s_e_t.  Removing a file descriptor that is not  present  in  the
              set is a no-op, and does not produce an error.

       FFDD__IISSSSEETT()
              sseelleecctt()  modifies  the contents of the sets according to the rules described below.  After calling sseelleecctt(),
              the FFDD__IISSSSEETT() macro can be used to test if a file descriptor is still present in a set.  FFDD__IISSSSEETT()  returns
              nonzero if the file descriptor _f_d is present in _s_e_t, and zero if it is not.

   AArrgguummeennttss
       The arguments of sseelleecctt() are as follows:

       _r_e_a_d_f_d_s
              The  file  descriptors  in  this  set are watched to see if they are ready for reading.  A file descriptor is
              ready for reading if a read operation will not block; in particular, a file descriptor is also ready on  end-
              of-file.

              After  sseelleecctt() has returned, _r_e_a_d_f_d_s will be cleared of all file descriptors except for those that are ready
              for reading.

       _w_r_i_t_e_f_d_s
              The file descriptors in this set are watched to see if they are ready for  writing.   A  file  descriptor  is
              ready  for  writing  if  a  write  operation will not block.  However, even if a file descriptor indicates as
              writable, a large write may still block.

              After sseelleecctt() has returned, _w_r_i_t_e_f_d_s will be cleared of all file descriptors except for those that are ready
              for writing.

       _e_x_c_e_p_t_f_d_s
              The  file descriptors in this set are watched for "exceptional conditions".  For examples of some exceptional
              conditions, see the discussion of PPOOLLLLPPRRII in ppoollll(2).

              After sseelleecctt() has returned, _e_x_c_e_p_t_f_d_s will be cleared of all file descriptors except for those for which  an
              exceptional condition has occurred.

       _n_f_d_s   This  argument  should  be set to the highest-numbered file descriptor in any of the three sets, plus 1.  The
              indicated file descriptors in each set are checked, up to this limit (but see BUGS).

       _t_i_m_e_o_u_t
              The _t_i_m_e_o_u_t argument is a _t_i_m_e_v_a_l structure (shown below) that specifies the interval  that  sseelleecctt()  should
              block waiting for a file descriptor to become ready.  The call will block until either:

              •  a file descriptor becomes ready;

              •  the call is interrupted by a signal handler; or

              •  the timeout expires.

              Note  that the _t_i_m_e_o_u_t interval will be rounded up to the system clock granularity, and kernel scheduling de‐
              lays mean that the blocking interval may overrun by a small amount.

              If both fields of the _t_i_m_e_v_a_l structure are zero, then sseelleecctt() returns immediately.   (This  is  useful  for
              polling.)

              If _t_i_m_e_o_u_t is specified as NULL, sseelleecctt() blocks indefinitely waiting for a file descriptor to become ready.

   ppsseelleecctt(())
       The ppsseelleecctt() system call allows an application to safely wait until either a file descriptor becomes ready or until
       a signal is caught.

       The operation of sseelleecctt() and ppsseelleecctt() is identical, other than these three differences:

       •  sseelleecctt() uses a timeout that is a _s_t_r_u_c_t _t_i_m_e_v_a_l (with seconds and microseconds), while ppsseelleecctt() uses  a  _s_t_r_u_c_t
          _t_i_m_e_s_p_e_c (with seconds and nanoseconds).

       •  sseelleecctt()  may update the _t_i_m_e_o_u_t argument to indicate how much time was left.  ppsseelleecctt() does not change this ar‐
          gument.

       •  sseelleecctt() has no _s_i_g_m_a_s_k argument, and behaves as ppsseelleecctt() called with NULL _s_i_g_m_a_s_k.

       _s_i_g_m_a_s_k is a pointer to a signal mask (see ssiiggpprrooccmmaasskk(2)); if it is not NULL, then  ppsseelleecctt()  first  replaces  the
       current  signal mask by the one pointed to by _s_i_g_m_a_s_k, then does the "select" function, and then restores the origi‐
       nal signal mask.  (If _s_i_g_m_a_s_k is NULL, the signal mask is not modified during the ppsseelleecctt() call.)

       Other than the difference in the precision of the _t_i_m_e_o_u_t argument, the following ppsseelleecctt() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to _a_t_o_m_i_c_a_l_l_y executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that ppsseelleecctt() is needed is that if one wants to wait for either a signal or for a file descriptor to be‐
       come  ready,  then  an  atomic test is needed to prevent race conditions.  (Suppose the signal handler sets a global
       flag and returns.  Then a test of this global flag followed by a call of sseelleecctt() could  hang  indefinitely  if  the
       signal  arrived just after the test but just before the call.  By contrast, ppsseelleecctt() allows one to first block sig‐
       nals, handle the signals that have come in, then call ppsseelleecctt() with the desired _s_i_g_m_a_s_k, avoiding the race.)

   TThhee ttiimmeeoouutt
       The _t_i_m_e_o_u_t argument for sseelleecctt() is a structure of the following type:

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

       The corresponding argument for ppsseelleecctt() is a ttiimmeessppeecc(3) structure.

       On Linux, sseelleecctt() modifies _t_i_m_e_o_u_t to reflect the amount of time not slept; most other implementations  do  not  do
       this.   (POSIX.1  permits either behavior.)  This causes problems both when Linux code which reads _t_i_m_e_o_u_t is ported
       to other operating systems, and when code is ported to Linux that reuses a _s_t_r_u_c_t _t_i_m_e_v_a_l for multiple sseelleecctt()s  in
       a loop without reinitializing it.  Consider _t_i_m_e_o_u_t to be undefined after sseelleecctt() returns.

RREETTUURRNN VVAALLUUEE
       On  success, sseelleecctt() and ppsseelleecctt() return the number of file descriptors contained in the three returned descriptor
       sets (that is, the total number of bits that are set in _r_e_a_d_f_d_s, _w_r_i_t_e_f_d_s, _e_x_c_e_p_t_f_d_s).  The return value may be zero
       if the timeout expired before any file descriptors became ready.

       On error, -1 is returned, and _e_r_r_n_o is set to indicate the error; the file descriptor sets are unmodified, and _t_i_m_e_‐
       _o_u_t becomes undefined.

EERRRROORRSS
       EEBBAADDFF  An invalid file descriptor was given in one of the sets.  (Perhaps a file descriptor that was already closed,
              or one on which an error has occurred.)  However, see BUGS.

       EEIINNTTRR  A signal was caught; see ssiiggnnaall(7).

       EEIINNVVAALL _n_f_d_s is negative or exceeds the RRLLIIMMIITT__NNOOFFIILLEE resource limit (see ggeettrrlliimmiitt(2)).

       EEIINNVVAALL The value contained within _t_i_m_e_o_u_t is invalid.

       EENNOOMMEEMM Unable to allocate memory for internal tables.

VVEERRSSIIOONNSS
       ppsseelleecctt() was added in Linux 2.6.16.  Prior to this, ppsseelleecctt() was emulated in glibc (but see BUGS).

SSTTAANNDDAARRDDSS
       sseelleecctt() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (sseelleecctt() first appeared in 4.2BSD).  Generally portable
       to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).  However, note that
       the System V variant typically sets the timeout variable before returning, but the BSD variant does not.

       ppsseelleecctt() is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008.

       ffdd__sseett is defined in POSIX.1-2001 and later.

NNOOTTEESS
       The following header also provides the _f_d___s_e_t type: _<_s_y_s_/_t_i_m_e_._h_>.

       An _f_d___s_e_t is a fixed size buffer.  Executing FFDD__CCLLRR() or FFDD__SSEETT() with a value of _f_d that is negative or is equal to
       or larger than FFDD__SSEETTSSIIZZEE will result in undefined behavior.  Moreover, POSIX requires _f_d to be  a  valid  file  de‐
       scriptor.

       The operation of sseelleecctt() and ppsseelleecctt() is not affected by the OO__NNOONNBBLLOOCCKK flag.

       On  some other UNIX systems, sseelleecctt() can fail with the error EEAAGGAAIINN if the system fails to allocate kernel-internal
       resources, rather than EENNOOMMEEMM as Linux does.  POSIX specifies this error for ppoollll(2), but not for sseelleecctt().   Porta‐
       ble programs may wish to check for EEAAGGAAIINN and loop, just as with EEIINNTTRR.

   TThhee sseellff--ppiippee ttrriicckk
       On  systems  that  lack  ppsseelleecctt(), reliable (and more portable) signal trapping can be achieved using the self-pipe
       trick.  In this technique, a signal handler writes a byte to a pipe whose other end is monitored by sseelleecctt() in  the
       main  program.   (To avoid possibly blocking when writing to a pipe that may be full or reading from a pipe that may
       be empty, nonblocking I/O is used when reading from and writing to the pipe.)

   EEmmuullaattiinngg uusslleeeepp((33))
       Before the advent of uusslleeeepp(3), some code employed a call to sseelleecctt() with all three sets empty, _n_f_d_s  zero,  and  a
       non-NULL _t_i_m_e_o_u_t as a fairly portable way to sleep with subsecond precision.

   CCoorrrreessppoonnddeennccee bbeettwweeeenn sseelleecctt(()) aanndd ppoollll(()) nnoottiiffiiccaattiioonnss
       Within  the  Linux  kernel source, we find the following definitions which show the correspondence between the read‐
       able, writable, and exceptional condition notifications of sseelleecctt() and the event notifications provided by  ppoollll(2)
       and eeppoollll(7):

           #define POLLIN_SET  (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN |
                                EPOLLHUP | EPOLLERR)
                              /* Ready for reading */
           #define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT |
                                EPOLLERR)
                              /* Ready for writing */
           #define POLLEX_SET  (EPOLLPRI)
                              /* Exceptional condition */

   MMuullttiitthhrreeaaddeedd aapppplliiccaattiioonnss
       If  a  file  descriptor being monitored by sseelleecctt() is closed in another thread, the result is unspecified.  On some
       UNIX systems, sseelleecctt() unblocks and returns, with an indication that the file descriptor is ready (a subsequent  I/O
       operation  will  likely  fail with an error, unless another process reopens the file descriptor between the time ssee‐‐
       lleecctt() returned and the I/O operation is performed).  On Linux (and some other systems), closing the file descriptor
       in  another  thread  has no effect on sseelleecctt().  In summary, any application that relies on a particular behavior in
       this scenario must be considered buggy.

   CC lliibbrraarryy//kkeerrnneell ddiiffffeerreenncceess
       The Linux kernel allows file descriptor sets of arbitrary size, determining the length of the  sets  to  be  checked
       from the value of _n_f_d_s.  However, in the glibc implementation, the _f_d___s_e_t type is fixed in size.  See also BUGS.

       The  ppsseelleecctt()  interface described in this page is implemented by glibc.  The underlying Linux system call is named
       ppsseelleecctt66().  This system call has somewhat different behavior from the glibc wrapper function.

       The Linux ppsseelleecctt66() system call modifies its _t_i_m_e_o_u_t argument.  However, the glibc wrapper function hides this  be‐
       havior  by  using a local variable for the timeout argument that is passed to the system call.  Thus, the glibc ppssee‐‐
       lleecctt() function does not modify its _t_i_m_e_o_u_t argument; this is the behavior required by POSIX.1-2001.

       The final argument of the ppsseelleecctt66() system call is not a _s_i_g_s_e_t___t _* pointer, but is  instead  a  structure  of  the
       form:

           struct {
               const kernel_sigset_t *ss;   /* Pointer to signal set */
               size_t ss_len;               /* Size (in bytes) of object
                                               pointed to by 'ss' */
           };

       This  allows  the  system  call to obtain both a pointer to the signal set and its size, while allowing for the fact
       that most architectures support a maximum of 6 arguments to a system call.  See ssiiggpprrooccmmaasskk(2) for a  discussion  of
       the difference between the kernel and libc notion of the signal set.

   HHiissttoorriiccaall gglliibbcc ddeettaaiillss
       glibc 2.0 provided an incorrect version of ppsseelleecctt() that did not take a _s_i_g_m_a_s_k argument.

       From  glibc  2.1  to  glibc  2.2.1, one must define __GGNNUU__SSOOUURRCCEE in order to obtain the declaration of ppsseelleecctt() from
       _<_s_y_s_/_s_e_l_e_c_t_._h_>.

BBUUGGSS
       POSIX allows an implementation to define an upper limit, advertised via the constant FFDD__SSEETTSSIIZZEE,  on  the  range  of
       file  descriptors  that can be specified in a file descriptor set.  The Linux kernel imposes no fixed limit, but the
       glibc implementation makes _f_d___s_e_t a fixed-size type, with FFDD__SSEETTSSIIZZEE defined as 1024, and the FFDD__**() macros  operat‐
       ing according to that limit.  To monitor file descriptors greater than 1023, use ppoollll(2) or eeppoollll(7) instead.

       The  implementation  of  the _f_d___s_e_t arguments as value-result arguments is a design error that is avoided in ppoollll(2)
       and eeppoollll(7).

       According to POSIX, sseelleecctt() should check all specified file descriptors in the three file descriptor  sets,  up  to
       the  limit  _n_f_d_s_-_1.   However,  the current implementation ignores any file descriptor in these sets that is greater
       than the maximum file descriptor number that the process currently has open.  According to POSIX, any such file  de‐
       scriptor that is specified in one of the sets should result in the error EEBBAADDFF.

       Starting  with glibc 2.1, glibc provided an emulation of ppsseelleecctt() that was implemented using ssiiggpprrooccmmaasskk(2) and ssee‐‐
       lleecctt().  This implementation remained vulnerable to the very race condition that ppsseelleecctt() was designed to  prevent.
       Modern versions of glibc use the (race-free) ppsseelleecctt() system call on kernels where it is provided.

       On  Linux, sseelleecctt() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read
       blocks.  This could for example happen when data has arrived but upon examination has the wrong checksum and is dis‐
       carded.   There  may be other circumstances in which a file descriptor is spuriously reported as ready.  Thus it may
       be safer to use OO__NNOONNBBLLOOCCKK on sockets that should not block.

       On Linux, sseelleecctt() also modifies _t_i_m_e_o_u_t if the call is interrupted by a signal handler (i.e., the EEIINNTTRR  error  re‐
       turn).   This  is  not  permitted  by POSIX.1.  The Linux ppsseelleecctt() system call has the same behavior, but the glibc
       wrapper hides this behavior by internally copying the _t_i_m_e_o_u_t to a local variable and passing that variable  to  the
       system call.

EEXXAAMMPPLLEESS
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/select.h>

       int
       main(void)
       {
           int             retval;
           fd_set          rfds;
           struct timeval  tv;

           /* Watch stdin (fd 0) to see when it has input. */

           FD_ZERO(&rfds);
           FD_SET(0, &rfds);

           /* Wait up to five seconds. */

           tv.tv_sec = 5;
           tv.tv_usec = 0;

           retval = select(1, &rfds, NULL, NULL, &tv);
           /* Don't rely on the value of tv now! */

           if (retval == -1)
               perror("select()");
           else if (retval)
               printf("Data is available now.\n");
               /* FD_ISSET(0, &rfds) will be true. */
           else
               printf("No data within five seconds.\n");

           exit(EXIT_SUCCESS);
       }

SSEEEE AALLSSOO
       aacccceepptt(2),  ccoonnnneecctt(2),  ppoollll(2),  rreeaadd(2),  rreeccvv(2),  rreessttaarrtt__ssyyssccaallll(2),  sseenndd(2), ssiiggpprrooccmmaasskk(2), wwrriittee(2), ttiimmee‐‐
       ssppeecc(3), eeppoollll(7), ttiimmee(7)

       For a tutorial with discussion and examples, see sseelleecctt__ttuutt(2).

Linux man-pages 6.03                                     2023-02-05                                               select(2)
